# -*- coding: utf-8 -*-
"""Demo3pm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i4O7cQwer4iEYSU0jKuaARDgKlBuOukr
"""

import numpy as np

# Importing 
import cupy as cp
from cupyx.scipy.sparse import csr_matrix
from scipy.sparse import lil_matrix

arr = np.loadtxt("foo.csv",
                 delimiter=",", dtype=np.float32)
# comment above code and add your numpy matrix to 'arr' variable

arr

size = arr.shape[0]
# add your size here 
print(size)
current_labels = cp.arange(start=0, stop = 34, dtype=cp.int32)

# Enter your number of edges
number_edges = 156

rows_input_file = cp.ndarray(number_edges, dtype=cp.int32)
colm_input_file = cp.ndarray(number_edges, dtype=cp.int32)
data_input_file = cp.ndarray(number_edges, dtype=cp.float32)

count = 0
for i,x in enumerate(arr):
  for j,z in enumerate(x):
    if z >0 :
      print(z)
      rows_input_file[count] = i
      colm_input_file[count] = j
      data_input_file[count] = z
      count = count + 1

def memlpa(current_labels, columns, size, row, data):
  
  flag = 1 # flag variable is used to exit the loop 
  iteration = 0 # iteration is important for history label

  mem_mat = csr_matrix((size, size), dtype=cp.float32) # sparse matrix to define the memory lpa, size is n X n 
  history = cp.random.rand(3,size) # history matrix to find termination cases, size is 3 X n

  history_adder = 0.00001



  while flag:     # we check initially of flag
   
    labels_from_columns = cp.zeros_like(columns) # setting an array to zero to absorb the new label values
    #print("Checker:::::::::::::::::::::::::::::::::::::::::::::")
    #print("Current Labels")
    #print(current_labels)

    #print("Columns")
    #print(columns)

    #print("labels from columns")
    #print(labels_from_columns)

    #print("Checker:::::::::::::::::::::::::::::::::::::::::::::")
    #trial_kernel((1,), (1024,), (current_labels, columns, labels_from_columns, len(row)))  #kernel call to get labels_from_columns     #TODO Change trial kernel for block size and number of threads
    #cp.cuda.Stream.null.synchronize()
    
    for itr in range(len(columns)):
      labels_from_columns[itr] = current_labels[columns[itr]]
      
    #cp.cuda.Stream.null.synchronize()
    #print("Labels from Columns")
    #print(labels_from_columns)

    #print("Rows")
    #print(row)
    #print("Rows Length")
    #print(len(row))

    #print("Data")
    #print(data)


    
    
    current_mem_mat = csr_matrix((data, (row, labels_from_columns)), shape=(size, size))  # create a new sparse matrix to store the current memory matrix 
    
    print("Current Value")
    print(current_mem_mat.toarray())

    mem_mat = mem_mat + current_mem_mat # adding the current memory matrix to the cumaltive mem matrix
    print(mem_mat.argmax(axis = 1))
    current_labels = mem_mat.argmax(axis = 1).reshape(-1) # extracting the max value of mem_mat to get the update labels
    print("Immediate current labels")
    print(current_labels)
    idx = iteration % 3 # 3 here is our chosen parameter
    history[idx] = current_labels # based on iteration number, store the current labels in the history matrix

    print("Memory Value")
    #print(mem_mat.toarray())
    mem_matrix = mem_mat.toarray()
    #f'{a:.2f}'
    for z in mem_matrix:
      for j in z:
        print(f'{j:.5f}', end=" ")
      print()


    hist_data = cp.full((size), history_adder)
    hist_row = cp.arange(start=0, stop = size, dtype=cp.int32)
    hist_labels_column = current_labels
    history_mem_mat = csr_matrix((hist_data, (hist_row, hist_labels_column)), shape=(size, size))
    mem_mat = mem_mat + history_mem_mat
    #history_mem_matrix = history_mem_mat.toarray()

    

    
    

    # below logic checks if past 3 updates are the same, essentially checking for convergence
    if cp.array_equal(history[0], history[1]):
      if cp.array_equal(history[1], history[2]):
        flag = 0    # setting flag to 0 to exit while looping
        pass
    iteration = iteration + 1 # incrementing iteration count
    
    print("The Current Labels are:")
    print(current_labels)
    print(":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::")
    #a = input("Hey")
  return current_labels

print(current_labels)

print(data_input_file)

final_labels = memlpa(current_labels, colm_input_file, 34, rows_input_file, data_input_file)

def label_2_list(new_labels):
  label = new_labels[0]
  label_bucket = []
  new_label = []
  new_label.append(0)
  visited = []
  for z in range(len(new_labels)):
    new_label = []
    for x in range(0, len(new_labels)):
      # get a label
      if new_labels[x] == z and x not in visited:
        new_label.append(x)
        visited.append(x)
      pass
    if len(new_label) > 0:
      label_bucket.append(new_label)

  return label_bucket

print(final_labels)

label_bucket = label_2_list(final_labels)

print(label_bucket)

import csv
data = label_bucket

with open('memlpa_nn_cupy_27_4_22_18.csv', mode='w') as file:
    writer = csv.writer(file)
    writer.writerows(data)

import warnings
warnings.filterwarnings('ignore')

# Download the csv file generated

